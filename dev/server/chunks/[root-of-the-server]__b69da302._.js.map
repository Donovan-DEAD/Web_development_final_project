{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/donov/OneDrive/Escritorio/Escuela/Semester_3/Web_development_final_project/z/refactor_page/src/lib/db.ts"],"sourcesContent":["import mongoose from 'mongoose';\nimport { insertRootUser } from './auth';\n\nconst MONGODB_URI = process.env.DATABASE_URL;\n\nif (!MONGODB_URI) {\n  throw new Error(\n    'Please define the DATABASE_URL environment variable inside .env.local'\n  );\n}\n\n/**\n * Global is used here to maintain a cached connection across hot reloads\n * in development. This prevents connections from growing exponentially\n * during API Route usage.\n */\nlet cached = (global as any).mongoose;\n\nif (!cached) {\n  cached = (global as any).mongoose = { conn: null, promise: null };\n}\n\nasync function connectToDatabase() {\n  if (cached.conn) {\n    return cached.conn;\n  }\n\n  if (!cached.promise) {\n    const opts = {\n      bufferCommands: false,\n    };\n\n    cached.promise = mongoose.connect(MONGODB_URI!, opts).then((mongoose) => {\n      return mongoose;\n    });\n  }\n  cached.conn = await cached.promise;\n  await insertRootUser()\n  return cached.conn;\n}\n\nexport default connectToDatabase;\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,YAAY;AAE5C,IAAI,CAAC,aAAa;IAChB,MAAM,IAAI,MACR;AAEJ;AAEA;;;;CAIC,GACD,IAAI,SAAS,yDAAgB,QAAQ;AAErC,IAAI,CAAC,QAAQ;IACX,SAAS,yDAAgB,QAAQ,GAAG;QAAE,MAAM;QAAM,SAAS;IAAK;AAClE;AAEA,eAAe;IACb,IAAI,OAAO,IAAI,EAAE;QACf,OAAO,OAAO,IAAI;IACpB;IAEA,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,MAAM,OAAO;YACX,gBAAgB;QAClB;QAEA,OAAO,OAAO,GAAG,oHAAQ,CAAC,OAAO,CAAC,aAAc,MAAM,IAAI,CAAC,CAAC;YAC1D,OAAO;QACT;IACF;IACA,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IAClC,MAAM,IAAA,gPAAc;IACpB,OAAO,OAAO,IAAI;AACpB;uCAEe"}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/donov/OneDrive/Escritorio/Escuela/Semester_3/Web_development_final_project/z/refactor_page/src/lib/models/user.ts"],"sourcesContent":["import mongoose, { Schema, Document, Model } from 'mongoose';\n\n// Interface for the User document\nexport interface IUser extends Document {\n  username: string;\n  email: string;\n  name: string;\n  perms: string;\n  permsLabel: string;\n  hash?: string;\n  salt?: string;\n}\n\nconst userSchema: Schema<IUser> = new Schema({\n  username: { type: String, unique: true, required: true },\n  email: { type: String, unique: true, required: true },\n  name: { type: String, required: true },\n  perms: { type: String, required: true },\n  hash: { type: String },\n  salt: { type: String },\n});\n\n// Define permsMap to ensure it's initialized with correct values or fallbacks\nconst getPermsMap = () => {\n  const map: { [key: string]: string } = {};\n  map[process.env.ADMIN_PERM_STR || 'admin_perm'] = 'admin';\n  map[process.env.USER_PERM_STR || 'user_perm'] = 'user';\n  map[process.env.EDITOR_PERM_STR || 'editor_perm'] = 'editor';\n  return map;\n};\n\n// Use a dynamic import or ensure process.env is ready if this is causing issues in some contexts\n// For a standard Next.js API route/server component, process.env should be available.\nconst permsMap = getPermsMap();\n\n// Log the permsMap to verify its content during initialization\nconsole.log('User model permsMap initialized:', permsMap);\n\nuserSchema.virtual('permsLabel').get(function (this: IUser) {\n  return permsMap[this.perms] || 'desconocido';\n});\n\nuserSchema.set('toObject', { virtuals: true });\nuserSchema.set('toJSON', { virtuals: true });\n\n// The passport-local-mongoose plugin is removed as we are using a custom JWT-based auth.\n// User authentication logic (password hashing and comparison) will be handled in the API routes.\n\n// Prevent model overwrite in Next.js hot-reloading environments\nconst User: Model<IUser> = mongoose.models.User || mongoose.model<IUser>('User', userSchema);\n\nexport default User;\n\n"],"names":[],"mappings":";;;;AAAA;;AAaA,MAAM,aAA4B,IAAI,mHAAM,CAAC;IAC3C,UAAU;QAAE,MAAM;QAAQ,QAAQ;QAAM,UAAU;IAAK;IACvD,OAAO;QAAE,MAAM;QAAQ,QAAQ;QAAM,UAAU;IAAK;IACpD,MAAM;QAAE,MAAM;QAAQ,UAAU;IAAK;IACrC,OAAO;QAAE,MAAM;QAAQ,UAAU;IAAK;IACtC,MAAM;QAAE,MAAM;IAAO;IACrB,MAAM;QAAE,MAAM;IAAO;AACvB;AAEA,8EAA8E;AAC9E,MAAM,cAAc;IAClB,MAAM,MAAiC,CAAC;IACxC,GAAG,CAAC,QAAQ,GAAG,CAAC,cAAc,IAAI,aAAa,GAAG;IAClD,GAAG,CAAC,QAAQ,GAAG,CAAC,aAAa,IAAI,YAAY,GAAG;IAChD,GAAG,CAAC,QAAQ,GAAG,CAAC,eAAe,IAAI,cAAc,GAAG;IACpD,OAAO;AACT;AAEA,iGAAiG;AACjG,sFAAsF;AACtF,MAAM,WAAW;AAEjB,+DAA+D;AAC/D,QAAQ,GAAG,CAAC,oCAAoC;AAEhD,WAAW,OAAO,CAAC,cAAc,GAAG,CAAC;IACnC,OAAO,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI;AACjC;AAEA,WAAW,GAAG,CAAC,YAAY;IAAE,UAAU;AAAK;AAC5C,WAAW,GAAG,CAAC,UAAU;IAAE,UAAU;AAAK;AAE1C,yFAAyF;AACzF,iGAAiG;AAEjG,gEAAgE;AAChE,MAAM,OAAqB,oHAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,oHAAQ,CAAC,KAAK,CAAQ,QAAQ;uCAElE"}},
    {"offset": {"line": 159, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/donov/OneDrive/Escritorio/Escuela/Semester_3/Web_development_final_project/z/refactor_page/src/lib/constants.ts"],"sourcesContent":["// Constants for password hashing parameters\nexport const PBKDF2_ITERATIONS = 10000;\nexport const PBKDF2_KEY_LENGTH = 512; // in bits, commonly 256 or 512\nexport const PBKDF2_DIGEST = 'sha512'; // Hashing algorithm\nexport const SALT_BYTES = 16; // in bytes, for randomBytes\n"],"names":[],"mappings":"AAAA,4CAA4C;;;;;;;;;;;AACrC,MAAM,oBAAoB;AAC1B,MAAM,oBAAoB,KAAK,+BAA+B;AAC9D,MAAM,gBAAgB,UAAU,oBAAoB;AACpD,MAAM,aAAa,IAAI,4BAA4B"}},
    {"offset": {"line": 184, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/donov/OneDrive/Escritorio/Escuela/Semester_3/Web_development_final_project/z/refactor_page/src/lib/auth.ts"],"sourcesContent":["\nimport connectToDatabase from './db';\nimport User, { IUser } from './models/user';\nimport mongoose from 'mongoose';\nimport {\n  PBKDF2_ITERATIONS,\n  PBKDF2_KEY_LENGTH,\n  PBKDF2_DIGEST,\n  SALT_BYTES\n} from './constants'; // Import hashing constants\n\n// Node.js 'crypto' for server-side operations (like password hashing)\nlet nodeCrypto: typeof import('crypto') | undefined;\nif (typeof process !== 'undefined') {\n  nodeCrypto = require('crypto');\n}\n\nconst ALGORITHM_AES_GCM = 'AES-GCM';\nconst IV_LENGTH_BYTES = 16; // 128 bits for AES-GCM IV\nconst AUTH_TAG_LENGTH_BITS = 128; // 128 bits for GCM auth tag\n\n// Ensure the secret key is defined\nconst secretKeyHex = process.env.AUTH_SECRET;\nif (!secretKeyHex) {\n  throw new Error('AUTH_SECRET environment variable is not set.');\n}\n\nlet encryptionKey: CryptoKey | undefined;\n\nasync function getEncryptionKey(): Promise<CryptoKey> {\n  if (encryptionKey) {\n    return encryptionKey;\n  }\n  const keyBuffer = Buffer.from(secretKeyHex, 'hex');\n  encryptionKey = await (globalThis.crypto || nodeCrypto.webcrypto).subtle.importKey(\n    'raw',\n    keyBuffer,\n    ALGORITHM_AES_GCM,\n    false,\n    ['encrypt', 'decrypt']\n  );\n  return encryptionKey;\n}\n\n/**\n * Encrypts a payload (e.g., a user ID) using Web Crypto API.\n * Uses AES-256-GCM to provide both confidentiality and authenticity.\n * @param payload The string data to encrypt.\n * @returns A string containing the iv, auth tag, and encrypted data, separated by colons.\n */\nexport async function encryptAndSign(payload: string): Promise<string> {\n  const key = await getEncryptionKey();\n  const iv = (globalThis.crypto || nodeCrypto.webcrypto).getRandomValues(new Uint8Array(IV_LENGTH_BYTES));\n  const encodedPayload = new TextEncoder().encode(payload);\n\n  const encryptedBuffer = await (globalThis.crypto || nodeCrypto.webcrypto).subtle.encrypt(\n    {\n      name: ALGORITHM_AES_GCM,\n      iv: iv,\n      tagLength: AUTH_TAG_LENGTH_BITS,\n    },\n    key,\n    encodedPayload\n  );\n\n  const ciphertext = new Uint8Array(encryptedBuffer.slice(0, encryptedBuffer.byteLength - (AUTH_TAG_LENGTH_BITS / 8)));\n  const authTag = new Uint8Array(encryptedBuffer.slice(encryptedBuffer.byteLength - (AUTH_TAG_LENGTH_BITS / 8)));\n\n  return `${Buffer.from(iv).toString('hex')}:${Buffer.from(authTag).toString('hex')}:${Buffer.from(ciphertext).toString('hex')}`;\n}\n\n/**\n * Decrypts a token and verifies its integrity using Web Crypto API.\n * @param token The token string created by encryptAndSign.\n * @returns The original payload if decryption and verification are successful; otherwise, null.\n */\nexport async function decryptAndVerify(token: string): Promise<string | null> {\n  try {\n    const key = await getEncryptionKey();\n    const parts = token.split(':');\n    if (parts.length !== 3) {\n      // Invalid format\n      return null;\n    }\n\n    const [ivHex, authTagHex, ciphertextHex] = parts;\n    const iv = Buffer.from(ivHex, 'hex');\n    const authTag = Buffer.from(authTagHex, 'hex');\n    const ciphertext = Buffer.from(ciphertextHex, 'hex');\n\n    // Combine ciphertext and authTag into a single buffer for decryption\n    const encryptedBuffer = new Uint8Array(ciphertext.byteLength + authTag.byteLength);\n    encryptedBuffer.set(ciphertext, 0);\n    encryptedBuffer.set(authTag, ciphertext.byteLength);\n\n    const decryptedBuffer = await (globalThis.crypto || nodeCrypto.webcrypto).subtle.decrypt(\n      {\n        name: ALGORITHM_AES_GCM,\n        iv: iv,\n        tagLength: AUTH_TAG_LENGTH_BITS,\n      },\n      key,\n      encryptedBuffer\n    );\n\n    return new TextDecoder().decode(decryptedBuffer);\n  } catch (error) {\n    console.error('Decryption failed:', error);\n    return null;\n  }\n}\n\n/**\n * Ensures the root user exists in the database. If not, it creates one.\n * This function uses Node.js 'crypto' and should only be called in a Node.js environment.\n */\nexport async function insertRootUser(): Promise<void> {\n    if (!nodeCrypto) {\n        console.error('Node.js crypto not available. Cannot run insertRootUser in this environment.');\n        return;\n    }\n\n    await connectToDatabase();\n\n    const ROOT_ID = process.env.ROOT_ID;\n    const ROOT_EMAIL = process.env.ROOT_EMAIL;\n    const ROOT_NAME = process.env.ROOT_NAME;\n    const ADMIN_PERM_STR = process.env.ADMIN_PERM_STR;\n    const ROOT_PASSWORD = process.env.ROOT_PASSWORD;\n\n    if (!ROOT_ID || !ROOT_EMAIL || !ROOT_NAME || !ADMIN_PERM_STR || !ROOT_PASSWORD) {\n        console.error('Missing one or more ROOT environment variables. Cannot create root user.');\n        return;\n    }\n\n    try {\n        const rootUser = await User.findById(new mongoose.Types.ObjectId(ROOT_ID));\n\n        if (!rootUser) {\n            const salt = nodeCrypto.randomBytes(SALT_BYTES).toString('hex');\n            const hash = nodeCrypto.pbkdf2Sync(ROOT_PASSWORD, salt, PBKDF2_ITERATIONS, PBKDF2_KEY_LENGTH, PBKDF2_DIGEST).toString('hex');\n\n            const newUser: IUser = new User({\n                _id: new mongoose.Types.ObjectId(ROOT_ID),\n                username: ROOT_EMAIL,\n                email: ROOT_EMAIL,\n                name: ROOT_NAME,\n                perms: ADMIN_PERM_STR,\n                hash: hash,\n                salt: salt,\n            });\n\n            await newUser.save();\n            console.log('Root user created successfully.');\n        } else {\n            console.log('Root user already exists.');\n        }\n    } catch (error) {\n        console.error('Error ensuring root user:', error);\n    }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 307, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/donov/OneDrive/Escritorio/Escuela/Semester_3/Web_development_final_project/z/refactor_page/src/lib/server-auth.ts"],"sourcesContent":["import { cookies } from 'next/headers';\nimport { decryptAndVerify } from '@/lib/auth';\nimport connectToDatabase from '@/lib/db';\nimport User, { IUser } from '@/lib/models/user';\n\nconst USER_COOKIE_NAME = 'user';\n\n/**\n * Retrieves the currently authenticated user from the request cookie.\n * This is a server-side utility.\n *\n * @returns {Promise<IUser | null>} The user object if authenticated, otherwise null.\n */\nexport async function getCurrentUser(): Promise<IUser | null> {\n  const tokenCookie = (await cookies()).get(USER_COOKIE_NAME);\n\n  if (tokenCookie) {\n    const token = tokenCookie.value;\n    const decryptedUserId = await decryptAndVerify(token);\n\n    if (decryptedUserId) {\n      await connectToDatabase();\n      const user = await User.findById(decryptedUserId); // Use .lean() for faster, plain JS objects\n      if (user) {\n        return user as IUser;\n      }\n    }\n  }\n\n  return null;\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,mBAAmB;AAQlB,eAAe;IACpB,MAAM,cAAc,CAAC,MAAM,IAAA,sPAAO,GAAE,EAAE,GAAG,CAAC;IAE1C,IAAI,aAAa;QACf,MAAM,QAAQ,YAAY,KAAK;QAC/B,MAAM,kBAAkB,MAAM,IAAA,kPAAgB,EAAC;QAE/C,IAAI,iBAAiB;YACnB,MAAM,IAAA,uOAAiB;YACvB,MAAM,OAAO,MAAM,mPAAI,CAAC,QAAQ,CAAC,kBAAkB,2CAA2C;YAC9F,IAAI,MAAM;gBACR,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 339, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/donov/OneDrive/Escritorio/Escuela/Semester_3/Web_development_final_project/z/refactor_page/src/lib/supabase.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\nimport { randomUUID } from 'crypto';\n\nconst SUPABASE_URL = process.env.SUPABASE_URL;\nconst SUPABASE_KEY = process.env.SUPABASE_KEY;\n\nif (!SUPABASE_URL || !SUPABASE_KEY) {\n  throw new Error('Supabase URL and Key must be defined in environment variables.');\n}\n\nconst supabase = createClient(SUPABASE_URL, SUPABASE_KEY);\n\nconst BUCKET_NAME = 'Images_for_blogs';\n\ninterface FileObject {\n  originalname: string;\n  buffer: Buffer;\n  mimetype: string;\n}\n\nconst sanitize = (str: string) => str.normalize('NFC').replace(/[^\\w.-]/g, '_');\n\nexport const uploadImageToSupabase = async (file: FileObject): Promise<string> => {\n  const fileName = `${randomUUID()}-${sanitize(file.originalname)}`;\n  \n  const { data, error } = await supabase.storage\n    .from(BUCKET_NAME)\n    .upload(fileName, file.buffer, {\n      cacheControl: '3600',\n      upsert: false,\n      contentType: file.mimetype,\n    });\n\n  if (error) {\n    console.error('Error uploading image to Supabase:', error);\n    throw new Error('Error uploading image to Supabase');\n  }\n\n  const { data: { publicUrl } } = supabase.storage.from(BUCKET_NAME).getPublicUrl(fileName);\n  return publicUrl;\n};\n\nexport const deleteImageFromSupabase = async (imageUrl: string): Promise<{ success: boolean }> => {\n  try {\n    const url = new URL(imageUrl);\n    const pathSegments = url.pathname.split('/');\n    const fileName = pathSegments.pop(); // Get the last segment\n\n    if (!fileName) {\n      throw new Error('Invalid image URL: Could not extract file name.');\n    }\n\n    // The bucket name is also in the path, let's make sure we're in the right one\n    const bucketFromUrl = pathSegments.pop();\n    if(bucketFromUrl !== BUCKET_NAME){\n        console.warn(`Attempted to delete from a bucket (${bucketFromUrl}) that does not match the configured bucket (${BUCKET_NAME}). The image URL might be incorrect.`);\n    }\n\n    const { error } = await supabase.storage.from(BUCKET_NAME).remove([fileName]);\n\n    if (error) {\n      throw new Error(`Error deleting image from Supabase: ${error.message}`);\n    }\n    return { success: true };\n  } catch (error) {\n    console.error('Error in deleteImageFromSupabase:', error);\n    throw error;\n  }\n};\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEA,MAAM,eAAe,QAAQ,GAAG,CAAC,YAAY;AAC7C,MAAM,eAAe,QAAQ,GAAG,CAAC,YAAY;AAE7C,IAAI,CAAC,gBAAgB,CAAC,cAAc;IAClC,MAAM,IAAI,MAAM;AAClB;AAEA,MAAM,WAAW,IAAA,mTAAY,EAAC,cAAc;AAE5C,MAAM,cAAc;AAQpB,MAAM,WAAW,CAAC,MAAgB,IAAI,SAAS,CAAC,OAAO,OAAO,CAAC,YAAY;AAEpE,MAAM,wBAAwB,OAAO;IAC1C,MAAM,WAAW,GAAG,IAAA,mHAAU,IAAG,CAAC,EAAE,SAAS,KAAK,YAAY,GAAG;IAEjE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,OAAO,CAC3C,IAAI,CAAC,aACL,MAAM,CAAC,UAAU,KAAK,MAAM,EAAE;QAC7B,cAAc;QACd,QAAQ;QACR,aAAa,KAAK,QAAQ;IAC5B;IAEF,IAAI,OAAO;QACT,QAAQ,KAAK,CAAC,sCAAsC;QACpD,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,EAAE,MAAM,EAAE,SAAS,EAAE,EAAE,GAAG,SAAS,OAAO,CAAC,IAAI,CAAC,aAAa,YAAY,CAAC;IAChF,OAAO;AACT;AAEO,MAAM,0BAA0B,OAAO;IAC5C,IAAI;QACF,MAAM,MAAM,IAAI,IAAI;QACpB,MAAM,eAAe,IAAI,QAAQ,CAAC,KAAK,CAAC;QACxC,MAAM,WAAW,aAAa,GAAG,IAAI,uBAAuB;QAE5D,IAAI,CAAC,UAAU;YACb,MAAM,IAAI,MAAM;QAClB;QAEA,8EAA8E;QAC9E,MAAM,gBAAgB,aAAa,GAAG;QACtC,IAAG,kBAAkB,aAAY;YAC7B,QAAQ,IAAI,CAAC,CAAC,mCAAmC,EAAE,cAAc,6CAA6C,EAAE,YAAY,oCAAoC,CAAC;QACrK;QAEA,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,OAAO,CAAC,IAAI,CAAC,aAAa,MAAM,CAAC;YAAC;SAAS;QAE5E,IAAI,OAAO;YACT,MAAM,IAAI,MAAM,CAAC,oCAAoC,EAAE,MAAM,OAAO,EAAE;QACxE;QACA,OAAO;YAAE,SAAS;QAAK;IACzB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,qCAAqC;QACnD,MAAM;IACR;AACF"}},
    {"offset": {"line": 402, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/donov/OneDrive/Escritorio/Escuela/Semester_3/Web_development_final_project/z/refactor_page/src/app/api/blogs/images/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getCurrentUser } from '@/lib/server-auth';\nimport { uploadImageToSupabase, deleteImageFromSupabase } from '@/lib/supabase';\n\nconst ADMIN_PERM = process.env.ADMIN_PERM_STR || 'admin_perm';\nconst EDITOR_PERM = process.env.EDITOR_PERM_STR || 'editor_perm';\n\n// --- POST Handler: Upload an Image ---\nexport async function POST(request: NextRequest) {\n  try {\n    const user = await getCurrentUser();\n    if (!user) {\n      return NextResponse.json({ message: 'Authentication required.' }, { status: 401 });\n    }\n\n    const hasPermission = user.perms === ADMIN_PERM || user.perms === EDITOR_PERM;\n    if (!hasPermission) {\n      return NextResponse.json({ message: 'You do not have permission to upload images.' }, { status: 403 });\n    }\n\n    const formData = await request.formData();\n    const file = formData.get('image') as File | null;\n\n    if (!file) {\n      return NextResponse.json({ message: 'No image file found in the request.' }, { status: 400 });\n    }\n\n    // Convert the File to a buffer\n    const buffer = Buffer.from(await file.arrayBuffer());\n\n    // Prepare the file object for the upload function\n    const fileToUpload = {\n      originalname: file.name,\n      buffer,\n      mimetype: file.type,\n    };\n\n    const publicUrl = await uploadImageToSupabase(fileToUpload);\n\n    return NextResponse.json({ imageUrl: publicUrl }, { status: 200 });\n\n  } catch (error) {\n    console.error('Error uploading image:', error);\n    return NextResponse.json({ message: 'An internal server error occurred during image upload.' }, { status: 500 });\n  }\n}\n\n// --- DELETE Handler: Delete an Image ---\nexport async function DELETE(request: NextRequest) {\n  try {\n    const user = await getCurrentUser();\n    if (!user) {\n      return NextResponse.json({ message: 'Authentication required.' }, { status: 401 });\n    }\n\n    const hasPermission = user.perms === ADMIN_PERM || user.perms === EDITOR_PERM;\n    if (!hasPermission) {\n      return NextResponse.json({ message: 'You do not have permission to delete images.' }, { status: 403 });\n    }\n\n    const { imageUrl } = await request.json();\n    if (!imageUrl) {\n      return NextResponse.json({ message: 'Image URL is required.' }, { status: 400 });\n    }\n\n    await deleteImageFromSupabase(imageUrl);\n    \n    return NextResponse.json({ message: 'Image deleted successfully.' }, { status: 200 });\n\n  } catch (error) {\n    console.error('Error deleting image:', error);\n    return NextResponse.json({ message: 'An internal server error occurred during image deletion.' }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,cAAc,IAAI;AACjD,MAAM,cAAc,QAAQ,GAAG,CAAC,eAAe,IAAI;AAG5C,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,IAAA,0PAAc;QACjC,IAAI,CAAC,MAAM;YACT,OAAO,0PAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAA2B,GAAG;gBAAE,QAAQ;YAAI;QAClF;QAEA,MAAM,gBAAgB,KAAK,KAAK,KAAK,cAAc,KAAK,KAAK,KAAK;QAClE,IAAI,CAAC,eAAe;YAClB,OAAO,0PAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAA+C,GAAG;gBAAE,QAAQ;YAAI;QACtG;QAEA,MAAM,WAAW,MAAM,QAAQ,QAAQ;QACvC,MAAM,OAAO,SAAS,GAAG,CAAC;QAE1B,IAAI,CAAC,MAAM;YACT,OAAO,0PAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAAsC,GAAG;gBAAE,QAAQ;YAAI;QAC7F;QAEA,+BAA+B;QAC/B,MAAM,SAAS,OAAO,IAAI,CAAC,MAAM,KAAK,WAAW;QAEjD,kDAAkD;QAClD,MAAM,eAAe;YACnB,cAAc,KAAK,IAAI;YACvB;YACA,UAAU,KAAK,IAAI;QACrB;QAEA,MAAM,YAAY,MAAM,IAAA,2PAAqB,EAAC;QAE9C,OAAO,0PAAY,CAAC,IAAI,CAAC;YAAE,UAAU;QAAU,GAAG;YAAE,QAAQ;QAAI;IAElE,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO,0PAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAyD,GAAG;YAAE,QAAQ;QAAI;IAChH;AACF;AAGO,eAAe,OAAO,OAAoB;IAC/C,IAAI;QACF,MAAM,OAAO,MAAM,IAAA,0PAAc;QACjC,IAAI,CAAC,MAAM;YACT,OAAO,0PAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAA2B,GAAG;gBAAE,QAAQ;YAAI;QAClF;QAEA,MAAM,gBAAgB,KAAK,KAAK,KAAK,cAAc,KAAK,KAAK,KAAK;QAClE,IAAI,CAAC,eAAe;YAClB,OAAO,0PAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAA+C,GAAG;gBAAE,QAAQ;YAAI;QACtG;QAEA,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,QAAQ,IAAI;QACvC,IAAI,CAAC,UAAU;YACb,OAAO,0PAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAAyB,GAAG;gBAAE,QAAQ;YAAI;QAChF;QAEA,MAAM,IAAA,6PAAuB,EAAC;QAE9B,OAAO,0PAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAA8B,GAAG;YAAE,QAAQ;QAAI;IAErF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO,0PAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAA2D,GAAG;YAAE,QAAQ;QAAI;IAClH;AACF"}}]
}